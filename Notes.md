### Creation Notes
- `dotnet new webapi` in empty directory.
- Added Npgsql PackageReference to comet-climate-server.csproj
- Added connection in WebAPIContext.cs
- Added Connection String to appsettings.Development.json
- Created Models folder with WebAPIContext.cs
- Created Models for each Table in the database (Weather, Twitter, Errors)
- Created DB Migration Create with `dotnet ef migrations add Create`
    - Can remove un-updated migrations with `dotnet ef migrations remove`
    - Can remove updated migrations with `dotnet ef migrations remove -f`
    - Migrations folder is auto-updated through these commands.
- Updated (created) database with `dotnet ef database update`
--- 
- Attempted to launch application locally, but routing failed.
- Had to change the Route in the default ValuesController.cs to an explicit route (Microsoft did not set a valid route).
---
- Started writing DataController.cs for requests to get data from all tables.
- Web Scraping with HtmlAgilityPack.
- Learned a lot about XPath selectors for webscraping.
- Got stuck on the second NWS site for HOURS.
    - I forgot the `<tbody>` tag is generated by Google Chrome, so it is a valid XPath selector in Chrome, but NOT through the HTML I received through HtmlAgilityPack.
    - I was using `document.execute(...)` in the Google Chrome Console to test my XPaths, so the `<tbody>` tag in the table was throwing me off.
---
- Learned about LINQ (Language Integrated Queries) in C#. 
    - Made it easy to format the JSON output from the API.
---
- I ran into trouble when creating a new Weather object in the WeatherScraper. It ended up creating an alias (another reference) to the same object opposed to copying the old data to duplicate object.
- With multiple objects with the same ID tag (since we are only wanting to update the data), I ran into a few errors regarding the DbContext and its tracking. 
- I found out the simplest fix ever: attach `.AsNoTracking().` to my `.FromSql()` object in the WeatherController constructor to detach it.
---
- At this point, I wanted to test how the server would be deployed before building the other half of the API.
- Wrote the Dockerfile.
- `heroku container:login`
- In /out (after publishing directory)
    - `dotnet publish -c Release -o out`
    - `cd out`
- `heroku container:push --app=comet-climate-server web`
- `heroku container:release --app=comet-climate-server web`
- Successfully deployed the first half of the API!
---
- The Twitter API now takes days to review usage...
---
- https://www.devtrends.co.uk/blog/handling-errors-in-asp.net-core-web-api
    - Good way to handle errors if searching/validating data.
    - Our API only involves two simple GET requests, however, so we only need a single error for calling an invalid page.
---
- I created a wildcard route (DefaultController) to throw a 404 for a bad request.
- I added global exception handling that sends a 500 (or other) error to the user (ErrorController).
---
- Added CORS. That was easy!
---
- I spent around three hours today researching and messing a bit with header authorization. 
- I cannot really figure it out and it is outside of this project, so for now I am going to leave the API unauthorized.
- I may return to this idea in the future.
---
